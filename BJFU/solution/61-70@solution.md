## 61#264

二叉树的左右孩子互换。首先读入一棵二叉树的先序遍历，然后顺着父亲遍历的同时交换其左右儿子的位置即可。注意0的位置是没有节点的。



## 62#265

双序遍历，注意调整输出节点信息的顺序即可。



## 63#266

在进行树上遍历的时候记录一下当前的层数的个数，最后只需要比较每层里的元素个数，输出最大宽度即可。



## 64#267

建树后遍历即可，记录最大深度并输出路径信息。



## 65#268

相当于dfs到叶节点后回溯输出到根节点的信息。与后序遍历类似，每个叶子节点的dfs结构大致是：

if(child) DFS(child); PRINT; return;



## 66#269

二叉树的前中后序遍历（传 统 艺 能），即调整输出信息和DFS的语句顺序就可以完成。



## 67#270

度数为0 1 2，即数儿子数量并统计，最后一期输出



## 68#271

一样是根据先序遍历建树，然后递归搜索输出高度。



## 69#272

和之前栈的题目一样，只是要求书写方式改为了二叉树，比较简单。



## 70#273

DIJKSTRA算法是非常经典的单源最短路算法，时间复杂度是O(VlogE)，基于BFS的思想，并且能记录此节点的上一个出发点，并用这个方式输出最短路的路径。是非常经典的图论算法，可以参考视频加以理解。

https://www.bilibili.com/video/av38254646

如果需要详解我也可以讲。